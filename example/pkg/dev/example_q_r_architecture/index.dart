// Generated by hollowpoint version 0.1.0
library x;
import "./foreign.dart" as $foreign;
class ExampleTermA {
    final dynamic value0;
    final dynamic value1;
    const ExampleTermA(this.value0, this.value1);
    static dynamic get create => (value0) {
        return (value1) {
            return ExampleTermA(value0, value1);
        };
    };
}
class ExampleTermB {
    final dynamic value0;
    final dynamic value1;
    const ExampleTermB(this.value0, this.value1);
    static dynamic get create => (value0) {
        return (value1) {
            return ExampleTermB(value0, value1);
        };
    };
}
class ExampleNullary {
    const ExampleNullary();
}
final dynamic ExampleNewtypeRecord = (x) {
    return x;
};
final dynamic ExampleNewtypeInt = (x) {
    return x;
};
class ExampleTypeclass {
    final dynamic getNullary1;
    final dynamic getNullary2;
    const ExampleTypeclass(this.getNullary1, this.getNullary2);
    static dynamic get create => (getNullary1) {
        return (getNullary2) {
            return ExampleTypeclass(getNullary1, getNullary2);
        };
    };
}
final dynamic updateRecordOpen = (v) {
    return (Map.from(v)).addAll({
        'hello': "hi"
    });
};
final dynamic updateRecordClosed = (hw) {
    final v = hw;
    return {
        'hello': v['hello'],
        'world': "updated"
    };
};
final dynamic getNullary2 = (dict) {
    return dict.getNullary2;
};
final dynamic getNullary1 = (dict) {
    return dict.getNullary1;
};
final etNewtypeInt = ExampleTypeclass((v) {
    return ExampleNullary();
}, (v) {
    return (v1) {
        return ExampleNullary();
    };
});
final dynamic doTCO = (v) {
    final $7 = v;
    if ($7 == 0) {
        return 0;
    };
    final x = $7;
    return doTCO($foreign.subtract(1)(x));
};
final dynamic doCaseMatch = (v) {
    final $8 = v;
    if ($8 is ExampleTermA) {
        final $9 = $8.value0;
        final $10 = $8.value1;
        return "A";
    };
    if ($8 is ExampleTermB) {
        final $11 = $8.value0;
        final $12 = $8.value1;
        return "B";
    };
    throw FallThroughError();
};
